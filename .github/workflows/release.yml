name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main, master]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && !contains(github.event.workflow_run.head_commit.message, '[skip ci]')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true
        token: ${{ secrets.GITHUB_TOKEN }}



    - name: Install git-cliff
      run: |
        curl -L https://github.com/orhun/git-cliff/releases/download/v2.2.2/git-cliff-2.2.2-x86_64-unknown-linux-gnu.tar.gz | tar -xz
        sudo mv git-cliff-2.2.2/git-cliff /usr/local/bin/

    - name: Install go-semantic-release
      run: |
        curl -L https://github.com/go-semantic-release/semantic-release/releases/download/v2.31.0/semantic-release_v2.31.0_linux_amd64 -o /usr/local/bin/semantic-release
        chmod +x /usr/local/bin/semantic-release

    - name: Generate changelog
      run: |
        git-cliff --latest --config cliff.toml --output CHANGELOG.md

    - name: Create release
      id: release
      run: |
        set -euo pipefail
        
        # Debug trap for errors
        trap 'echo "âŒ Error on line $LINENO. Command was: $BASH_COMMAND. Exit code: $?" >&2' ERR
        
        echo "ðŸ” Debugging git state..."
        echo "Current directory: $(pwd)"
        echo "Current commit: $(git rev-parse HEAD)"
        echo "Current branch: $(git branch --show-current)"
        echo ""
        echo "ðŸ·ï¸  Available tags before fetch:"
        git tag --sort=-version:refname | head -10 || echo "No tags found"
        echo ""
        echo "ðŸ“¥ Fetching remote tags..."
        git fetch --tags origin
        echo ""
        echo "ðŸ·ï¸  Available tags after fetch:"
        git tag --sort=-version:refname | head -10 || echo "No tags found after fetch"
        echo ""
        echo "ðŸ“Š Git describe test:"
        git describe --tags --abbrev=0 || echo "git describe failed"
        echo ""
        echo "Checking for releasable changes..."
        
        # Check if there are any changes since last release
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        echo "ðŸ“ LAST_TAG from git describe: '$LAST_TAG'"
        
        # Fallback to alternative method if describe failed
        if [ -z "$LAST_TAG" ]; then
            echo "ðŸ”„ Trying alternative method to get last tag..."
            LAST_TAG=$(git tag --sort=-version:refname | head -n 1 2>/dev/null || echo "")
            echo "ðŸ“ LAST_TAG from alternative method: '$LAST_TAG'"
        fi
        
        if [ -z "$LAST_TAG" ] || [ "$LAST_TAG" = "" ]; then
          echo "âœ… No tags found, this will be the first release"
          NEXT_VERSION="v0.1.0"
        else
          echo "âœ… Found last tag: $LAST_TAG"
          
          # Count commits since last tag with error handling
          echo "ðŸ“Š Counting commits since $LAST_TAG..."
          COMMITS_SINCE_TAG=$(git rev-list --count $LAST_TAG..HEAD 2>/dev/null || echo "0")
          echo "ðŸ“ˆ COMMITS_SINCE_TAG: $COMMITS_SINCE_TAG"
          
          if [ -z "$COMMITS_SINCE_TAG" ]; then
            COMMITS_SINCE_TAG="0"
          fi
          
          if [ "$COMMITS_SINCE_TAG" = "0" ]; then
            echo "â„¹ï¸  No new commits since last tag ($LAST_TAG)"
            echo "version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Use simple version increment logic
          echo "ðŸ” Analyzing commits for version bump..."
          if git log --format="%s" $LAST_TAG..HEAD | grep -q "^feat"; then
            BUMP="minor"
          elif git log --format="%s" $LAST_TAG..HEAD | grep -q "^fix"; then
            BUMP="patch"
          else
            BUMP="patch"
          fi

          echo "ðŸ”¢ Parsing version from $LAST_TAG..."
          CURRENT_VERSION=${LAST_TAG#v}
          echo "  CURRENT_VERSION: $CURRENT_VERSION"
          
          # Use cut instead of array for better compatibility
          MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
          MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
          PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
          
          echo "  MAJOR: $MAJOR"
          echo "  MINOR: $MINOR"
          echo "  PATCH: $PATCH"
          echo "  BUMP type: $BUMP"
          
          # Validate version parts
          if [ -z "$MAJOR" ] || [ -z "$MINOR" ] || [ -z "$PATCH" ]; then
            echo "âŒ ERROR: Failed to parse version parts from $CURRENT_VERSION"
            exit 1
          fi

          case $BUMP in
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
          esac

          echo "  After bump: MAJOR=$MAJOR MINOR=$MINOR PATCH=$PATCH"
          NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "ðŸŽ¯ Calculated NEXT_VERSION: $NEXT_VERSION"
        fi
        
        # Validate that we have a version
        if [ -z "$NEXT_VERSION" ] || [ "$NEXT_VERSION" = "" ]; then
            echo "âŒ ERROR: NEXT_VERSION is empty or undefined"
            echo "version=" >> $GITHUB_OUTPUT
            exit 1
        fi
        
        # Validate version format
        if [[ ! "$NEXT_VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Invalid version format: $NEXT_VERSION"
            exit 1
        fi
        
        echo "âœ… Successfully determined and validated version: $NEXT_VERSION"
        echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT

        # Commit changelog update
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add CHANGELOG.md
        if [ -n "$(git status --porcelain CHANGELOG.md)" ]; then
          git commit -m "chore: update changelog for $NEXT_VERSION [skip ci]"
          git push origin main
        fi

        # Create tag
        git tag -a $NEXT_VERSION -m "Release $NEXT_VERSION"

        # Generate release notes for current version only
        git-cliff --config cliff-github.toml --latest --tag $NEXT_VERSION > release_notes.md

        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        cat release_notes.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      if: steps.release.outputs.version != ''
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.release.outputs.version }}
        name: Release ${{ steps.release.outputs.version }}
        body: ${{ steps.release.outputs.changelog }}
        generate_release_notes: false
        draft: false
        prerelease: false

