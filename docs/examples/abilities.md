# ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Abilities

Ð—Ð´ÐµÑÑŒ ÑÐ¾Ð±Ñ€Ð°Ð½Ñ‹ Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ñ‹ Abilities Ð´Ð»Ñ Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… ÑÑ†ÐµÐ½Ð°Ñ€Ð¸ÐµÐ² Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ.

## ðŸ—„ï¸ Database Ability (PostgreSQL)

ÐŸÐ¾Ð»Ð½Ð°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ PostgreSQL Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ….

### Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ

```go
package database

import (
    "database/sql"
    "fmt"
    _ "github.com/lib/pq"
    
    "github.com/nchursin/serenity-go/serenity/abilities"
)

// DatabaseAbility - ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ð±Ð°Ð·Ð°Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…
type DatabaseAbility interface {
    abilities.Ability
    
    // Connection management
    Connect(dsn string) error
    Disconnect() error
    Ping() error
    
    // Query operations
    Query(query string, args ...interface{}) (*sql.Rows, error)
    QueryRow(query string, args ...interface{}) *sql.Row
    Execute(query string, args ...interface{}) (sql.Result, error)
    
    // Transaction management
    BeginTx() (*sql.Tx, error)
    
    // State information
    LastQuery() string
    LastError() error
    IsConnected() bool
}
```

### Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ

```go
type databaseAbility struct {
    db         *sql.DB
    lastQuery  string
    lastError  error
    dsn        string
    mutex      sync.RWMutex
}

// ConnectToPostgreSQL - ÑÐ¾Ð·Ð´Ð°ÐµÑ‚ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ðº PostgreSQL
func ConnectToPostgreSQL(dsn string) DatabaseAbility {
    return &databaseAbility{
        dsn: dsn,
    }
}

func (d *databaseAbility) Connect(dsn string) error {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    
    if dsn != "" {
        d.dsn = dsn
    }
    
    db, err := sql.Open("postgres", d.dsn)
    if err != nil {
        d.lastError = fmt.Errorf("failed to open database: %w", err)
        return d.lastError
    }
    
    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ
    if err := db.Ping(); err != nil {
        d.lastError = fmt.Errorf("failed to ping database: %w", err)
        db.Close()
        return d.lastError
    }
    
    d.db = db
    d.lastError = nil
    return nil
}

func (d *databaseAbility) Query(query string, args ...interface{}) (*sql.Rows, error) {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    
    if d.db == nil {
        err := fmt.Errorf("database not connected")
        d.lastError = err
        d.lastQuery = query
        return nil, err
    }
    
    d.lastQuery = query
    rows, err := d.db.Query(query, args...)
    d.lastError = err
    return rows, err
}

func (d *databaseAbility) Execute(query string, args ...interface{}) (sql.Result, error) {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    
    if d.db == nil {
        err := fmt.Errorf("database not connected")
        d.lastError = err
        d.lastQuery = query
        return nil, err
    }
    
    d.lastQuery = query
    result, err := d.db.Exec(query, args...)
    d.lastError = err
    return result, err
}

func (d *databaseAbility) Disconnect() error {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    
    if d.db != nil {
        err := d.db.Close()
        d.db = nil
        d.lastError = err
        return err
    }
    return nil
}
```

### Activities

```go
// CreateTableActivity - ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹
type CreateTableActivity struct {
    tableName string
    schema    string
}

func CreateTable(tableName, schema string) *CreateTableActivity {
    return &CreateTableActivity{
        tableName: tableName,
        schema:    schema,
    }
}

func (c *CreateTableActivity) PerformAs(actor core.Actor) error {
    ability, err := actor.AbilityTo(&databaseAbility{})
    if err != nil {
        return fmt.Errorf("actor does not have database ability: %w", err)
    }
    
    db := ability.(DatabaseAbility)
    _, err = db.Execute(c.schema)
    return err
}

func (c *CreateTableActivity) Description() string {
    return fmt.Sprintf("creates table: %s", c.tableName)
}

// InsertDataActivity - Ð²ÑÑ‚Ð°Ð²ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ…
type InsertDataActivity struct {
    table string
    data  map[string]interface{}
}

func InsertInto(table string, data map[string]interface{}) *InsertDataActivity {
    return &InsertDataActivity{table: table, data: data}
}

func (i *InsertDataActivity) PerformAs(actor core.Actor) error {
    ability, err := actor.AbilityTo(&databaseAbility{})
    if err != nil {
        return fmt.Errorf("actor does not have database ability: %w", err)
    }
    
    db := ability.(DatabaseAbility)
    
    // Build INSERT query
    columns := make([]string, 0, len(i.data))
    placeholders := make([]string, 0, len(i.data))
    values := make([]interface{}, 0, len(i.data))
    
    for column, value := range i.data {
        columns = append(columns, column)
        placeholders = append(placeholders, fmt.Sprintf("$%d", len(columns)))
        values = append(values, value)
    }
    
    query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
        i.table,
        strings.Join(columns, ", "),
        strings.Join(placeholders, ", "),
    )
    
    _, err = db.Execute(query, values...)
    return err
}
```

### Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ

```go
func TestDatabaseOperations(t *testing.T) {
    actor := core.NewActor("DBAdmin").WhoCan(
        database.ConnectToPostgreSQL("postgres://user:pass@localhost/testdb?sslmode=disable"),
    )
    
    err := actor.AttemptsTo(
        // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ÑÑ Ðº Ð±Ð°Ð·Ðµ
        core.Do("connects to database", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&databaseAbility{})
            return ability.(DatabaseAbility).Connect("")
        }),
        
        // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñƒ
        database.CreateTable("users", `
            CREATE TABLE users (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                email VARCHAR(255) UNIQUE NOT NULL,
                created_at TIMESTAMP DEFAULT NOW()
            )
        `),
        
        // Ð’ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ
        database.InsertInto("users", map[string]interface{}{
            "name":  "John Doe",
            "email": "john@example.com",
        }),
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚
        ensure.That(database.RowCount("users"), expectations.Equals(1)),
    )
    
    require.NoError(t, err)
    
    // ÐžÑ‡Ð¸ÑÑ‚ÐºÐ°
    cleanupActor := core.NewActor("DBCleaner").WhoCan(
        database.ConnectToPostgreSQL("postgres://user:pass@localhost/testdb?sslmode=disable"),
    )
    
    cleanupErr := cleanupActor.AttemptsTo(
        core.Do("connects to database", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&databaseAbility{})
            return ability.(DatabaseAbility).Connect("")
        }),
        database.DropTable("users"),
    )
    
    require.NoError(t, cleanupErr)
}
```

## ðŸ—‚ï¸ FileSystem Ability

Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ„Ð°Ð¹Ð»Ð¾Ð²Ð¾Ð¹ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ Ñ backup Ð¸ Ð²ÐµÑ€ÑÐ¸Ð¾Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼.

### Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ

```go
package filesystem

import (
    "io/fs"
    "time"
)

// FileSystemAbility - Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð°Ñ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ñ„Ð°Ð¹Ð»Ð°Ð¼Ð¸
type FileSystemAbility interface {
    abilities.Ability
    
    // Basic operations
    ReadFile(path string) ([]byte, error)
    WriteFile(path string, data []byte, perm fs.FileMode) error
    DeleteFile(path string) error
    Exists(path string) bool
    
    // Directory operations
    CreateDir(path string, perm fs.FileMode) error
    ListDir(path string) ([]fs.DirEntry, error)
    
    // Advanced features
    BackupFile(path string) (string, error)
    RestoreFile(backupPath string) error
    GetFileSize(path string) int64
    GetFileModTime(path string) time.Time
    
    // Working directory
    SetWorkingDirectory(dir string) error
    GetWorkingDirectory() string
    
    // State
    LastOperation() string
}
```

### Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ

```go
type fileSystemAbility struct {
    workingDir   string
    backupDir    string
    lastOp       string
    backups      map[string]string // original -> backup path
    mutex        sync.RWMutex
}

func ManageFileSystem() FileSystemAbility {
    return &fileSystemAbility{
        workingDir: ".",
        backupDir:  ".backups",
        backups:    make(map[string]string),
    }
}

func ManageFileSystemIn(directory string) FileSystemAbility {
    abs, _ := filepath.Abs(directory)
    return &fileSystemAbility{
        workingDir: abs,
        backupDir:  filepath.Join(abs, ".backups"),
        backups:    make(map[string]string),
    }
}

func (f *fileSystemAbility) WriteFile(path string, data []byte, perm fs.FileMode) error {
    f.mutex.Lock()
    defer f.mutex.Unlock()
    
    fullPath := filepath.Join(f.workingDir, path)
    
    // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾
    if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
        f.lastOp = fmt.Sprintf("mkdir error: %s", path)
        return fmt.Errorf("failed to create directory: %w", err)
    }
    
    if err := os.WriteFile(fullPath, data, perm); err != nil {
        f.lastOp = fmt.Sprintf("write error: %s", path)
        return fmt.Errorf("failed to write file: %w", err)
    }
    
    f.lastOp = fmt.Sprintf("write: %s", path)
    return nil
}

func (f *fileSystemAbility) BackupFile(path string) (string, error) {
    f.mutex.Lock()
    defer f.mutex.Unlock()
    
    fullPath := filepath.Join(f.workingDir, path)
    
    // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ backup Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ
    if err := os.MkdirAll(f.backupDir, 0755); err != nil {
        return "", fmt.Errorf("failed to create backup directory: %w", err)
    }
    
    // Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ð¼Ñ backup Ñ„Ð°Ð¹Ð»Ð°
    timestamp := time.Now().Format("20060102-150405")
    backupName := fmt.Sprintf("%s_%s_%s", 
        filepath.Base(path), 
        strings.TrimSuffix(filepath.Ext(path), "."), 
        timestamp,
    )
    backupPath := filepath.Join(f.backupDir, backupName)
    
    // ÐšÐ¾Ð¿Ð¸Ñ€ÑƒÐµÐ¼ Ñ„Ð°Ð¹Ð»
    if err := copyFile(fullPath, backupPath); err != nil {
        return "", fmt.Errorf("failed to backup file: %w", err)
    }
    
    f.backups[path] = backupPath
    f.lastOp = fmt.Sprintf("backup: %s -> %s", path, backupPath)
    return backupPath, nil
}

func (f *fileSystemAbility) RestoreFile(backupPath string) error {
    f.mutex.Lock()
    defer f.mutex.Unlock()
    
    // ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ
    var originalPath string
    for orig, backup := range f.backups {
        if backup == backupPath {
            originalPath = orig
            break
        }
    }
    
    if originalPath == "" {
        return fmt.Errorf("backup not found: %s", backupPath)
    }
    
    fullPath := filepath.Join(f.workingDir, originalPath)
    
    if err := copyFile(backupPath, fullPath); err != nil {
        f.lastOp = fmt.Sprintf("restore error: %s", originalPath)
        return fmt.Errorf("failed to restore file: %w", err)
    }
    
    f.lastOp = fmt.Sprintf("restore: %s", originalPath)
    return nil
}

func copyFile(src, dst string) error {
    source, err := os.Open(src)
    if err != nil {
        return err
    }
    defer source.Close()
    
    destination, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer destination.Close()
    
    _, err = io.Copy(destination, source)
    return err
}
```

### Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ

```go
func TestFileSystemWithBackup(t *testing.T) {
    tempDir := t.TempDir()
    
    actor := core.NewActor("FileEditor").WhoCan(
        filesystem.ManageFileSystemIn(tempDir),
    )
    
    originalContent := "original content"
    modifiedContent := "modified content"
    
    err := actor.AttemptsTo(
        // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»
        core.Do("creates original file", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&fileSystemAbility{})
            return ability.(FileSystemAbility).WriteFile(
                "important.txt", 
                []byte(originalContent), 
                0644,
            )
        }),
        
        // Ð”ÐµÐ»Ð°ÐµÐ¼ backup
        filesystem.BackupUpFile("important.txt"),
        
        // ÐœÐ¾Ð´Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€ÑƒÐµÐ¼ Ñ„Ð°Ð¹Ð»
        core.Do("modifies file", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&fileSystemAbility{})
            return ability.(FileSystemAbility).WriteFile(
                "important.txt", 
                []byte(modifiedContent), 
                0644,
            )
        }),
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸ÑŽ
        ensure.That(filesystem.FileContent("important.txt"), expectations.Equals(modifiedContent)),
        
        // Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð¸Ð· backup
        filesystem.RestoreLastBackup("important.txt"),
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ
        ensure.That(filesystem.FileContent("important.txt"), expectations.Equals(originalContent)),
    )
    
    require.NoError(t, err)
}
```

## ðŸ”Œ WebSocket Ability

Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ WebSocket ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸ÑÐ¼Ð¸.

### Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ

```go
package websocket

import (
    "time"
    "github.com/gorilla/websocket"
)

// WebSocketAbility - ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ WebSocket
type WebSocketAbility interface {
    abilities.Ability
    
    // Connection management
    Connect(url string, header http.Header) error
    Disconnect() error
    IsConnected() bool
    
    // Messaging
    Send(message []byte) error
    SendJSON(v interface{}) error
    Receive(timeout time.Duration) ([]byte, error)
    ReceiveJSON(v interface{}, timeout time.Duration) error
    
    // State
    LastMessage() []byte
    ConnectionDuration() time.Duration
    MessageCount() int
}
```

### Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ

```go
type webSocketAbility struct {
    conn           *websocket.Conn
    lastMessage    []byte
    connectTime    time.Time
    messageCount   int
    mutex          sync.RWMutex
    dialer         websocket.Dialer
    pingInterval   time.Duration
    pongWait       time.Duration
}

func ConnectToWebSocket() WebSocketAbility {
    return &webSocketAbility{
        dialer:       *websocket.DefaultDialer,
        pingInterval: 30 * time.Second,
        pongWait:     60 * time.Second,
    }
}

func ConnectToWebSocketWithTimeout(timeout time.Duration) WebSocketAbility {
    dialer := websocket.DefaultDialer
    dialer.HandshakeTimeout = timeout
    
    return &webSocketAbility{
        dialer:       *dialer,
        pingInterval: 30 * time.Second,
        pongWait:     60 * time.Second,
    }
}

func (w *webSocketAbility) Connect(url string, header http.Header) error {
    w.mutex.Lock()
    defer w.mutex.Unlock()
    
    conn, resp, err := w.dialer.Dial(url, header)
    if err != nil {
        return fmt.Errorf("failed to connect to websocket: %w", err)
    }
    
    if resp != nil && resp.Body != nil {
        resp.Body.Close()
    }
    
    w.conn = conn
    w.connectTime = time.Now()
    w.messageCount = 0
    
    // Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ ping/pong handler
    go w.startPingPong()
    
    return nil
}

func (w *webSocketAbility) Send(message []byte) error {
    w.mutex.RLock()
    defer w.mutex.RUnlock()
    
    if w.conn == nil {
        return fmt.Errorf("not connected to websocket")
    }
    
    err := w.conn.WriteMessage(websocket.TextMessage, message)
    if err == nil {
        w.messageCount++
    }
    return err
}

func (w *webSocketAbility) Receive(timeout time.Duration) ([]byte, error) {
    w.mutex.Lock()
    defer w.mutex.Unlock()
    
    if w.conn == nil {
        return nil, fmt.Errorf("not connected to websocket")
    }
    
    // Set read deadline
    if timeout > 0 {
        err := w.conn.SetReadDeadline(time.Now().Add(timeout))
        if err != nil {
            return nil, fmt.Errorf("failed to set read deadline: %w", err)
        }
    }
    
    messageType, message, err := w.conn.ReadMessage()
    if err != nil {
        return nil, fmt.Errorf("failed to read message: %w", err)
    }
    
    if messageType == websocket.TextMessage {
        w.lastMessage = message
        w.messageCount++
    }
    
    return message, nil
}

func (w *webSocketAbility) startPingPong() {
    ticker := time.NewTicker(w.pingInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            w.mutex.RLock()
            conn := w.conn
            w.mutex.RUnlock()
            
            if conn == nil {
                return
            }
            
            if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                conn.Close()
                return
            }
        }
    }
}
```

### Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ

```go
func TestWebSocketChat(t *testing.T) {
    // Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ WebSocket ÑÐµÑ€Ð²ÐµÑ€
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        upgrader := websocket.Upgrader{}
        conn, _ := upgrader.Upgrade(w, r, nil)
        
        defer conn.Close()
        
        for {
            messageType, message, err := conn.ReadMessage()
            if err != nil {
                break
            }
            
            // Echo message back
            conn.WriteMessage(messageType, message)
        }
    }))
    defer server.Close()
    
    // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ HTTP URL Ð² WebSocket URL
    wsURL := "ws" + strings.TrimPrefix(server.URL, "http") + "/ws"
    
    actor := core.NewActor("WebSocketClient").WhoCan(
        websocket.ConnectToWebSocket(),
    )
    
    err := actor.AttemptsTo(
        // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ÑÑ Ðº WebSocket
        core.Do("connects to websocket", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&webSocketAbility{})
            return ability.(WebSocketAbility).Connect(wsURL, nil)
        }),
        
        // ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
        core.Do("sends message", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&webSocketAbility{})
            return ability.(WebSocketAbility).Send([]byte("Hello WebSocket!"))
        }),
        
        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ñ‚Ð²ÐµÑ‚
        core.Do("receives response", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&webSocketAbility{})
            _, err := ability.(WebSocketAbility).Receive(5 * time.Second)
            return err
        }),
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
        ensure.That(websocket.LastMessage(), expectations.Equals([]byte("Hello WebSocket!"))),
        ensure.That(websocket.MessageCount(), expectations.Equals(2)), // Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾ + Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¾
    )
    
    require.NoError(t, err)
}
```

## ðŸ“Š Redis Ability

Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Redis.

### Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ

```go
package redis

import "github.com/go-redis/redis/v8"

// RedisAbility - ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Redis
type RedisAbility interface {
    abilities.Ability
    
    // Connection
    Connect(addr string, options *redis.Options) error
    Disconnect() error
    Ping() error
    
    // Basic operations
    Set(key string, value interface{}, expiration time.Duration) error
    Get(key string) (string, error)
    Del(keys ...string) error
    Exists(keys ...string) (int64, error)
    
    // Hash operations
    HSet(key string, values ...interface{}) error
    HGet(key, field string) (string, error)
    HGetAll(key string) (map[string]string, error)
    
    // List operations
    LPush(key string, values ...interface{}) error
    RPop(key string) (string, error)
    LRange(key string, start, stop int64) ([]string, error)
    
    // State
    LastCommand() string
    ConnectionInfo() string
}
```

### ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ

```go
func TestRedisOperations(t *testing.T) {
    // ÐŸÑ€ÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÐ¼, Ñ‡Ñ‚Ð¾ Ñƒ Ð²Ð°Ñ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ Redis Ð½Ð° localhost:6379
    actor := core.NewActor("RedisUser").WhoCan(
        redis.ConnectToRedis("localhost:6379"),
    )
    
    err := actor.AttemptsTo(
        // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ÑÑ Ðº Redis
        core.Do("connects to redis", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&redisAbility{})
            return ability.(RedisAbility).Connect("", &redis.Options{
                Addr: "localhost:6379",
            })
        }),
        
        // Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
        core.Do("sets key-value", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&redisAbility{})
            return ability.(RedisAbility).Set("test:key", "test-value", 0)
        }),
        
        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
        core.Do("gets value", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&redisAbility{})
            val, err := ability.(RedisAbility).Get("test:key")
            if err != nil {
                return err
            }
            // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸
            return nil
        }),
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÑƒÑ‰ÐµÑÑ‚Ð²Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ»ÑŽÑ‡Ð°
        ensure.That(redis.KeyExists("test:key"), expectations.IsTrue()),
        ensure.That(redis.StringValue("test:key"), expectations.Equals("test-value")),
        
        // Ð£Ð´Ð°Ð»ÑÐµÐ¼ ÐºÐ»ÑŽÑ‡
        core.Do("deletes key", func(actor core.Actor) error {
            ability, _ := actor.AbilityTo(&redisAbility{})
            return ability.(RedisAbility).Del("test:key")
        }),
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ
        ensure.That(redis.KeyExists("test:key"), expectations.IsFalse()),
    )
    
    require.NoError(t, err)
}
```

---

Ð­Ñ‚Ð¸ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ñ‹ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‚ Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ñ‹ Ðº ÑÐ¾Ð·Ð´Ð°Ð½Ð¸ÑŽ Abilities:

1. **Database Ability** - ÐºÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ Ñ connection management
2. **FileSystem Ability** - Ð¿Ñ€Ð¾Ð´Ð²Ð¸Ð½ÑƒÑ‚Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ backup Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑÐ¼Ð¸
3. **WebSocket Ability** - Ñ€Ð°Ð±Ð¾Ñ‚Ð° Ñ real-time ÐºÐ¾Ð¼Ð¼ÑƒÐ½Ð¸ÐºÐ°Ñ†Ð¸ÑÐ¼Ð¸
4. **Redis Ability** - Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ñ Ð¿Ð¾Ð¿ÑƒÐ»ÑÑ€Ð½Ñ‹Ð¼ in-memory storage

ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ ÑÐ»ÐµÐ´ÑƒÐµÑ‚ Ð¿Ð°Ñ‚Ñ‚ÐµÑ€Ð½Ð°Ð¼, Ð¾Ð¿Ð¸ÑÐ°Ð½Ð½Ñ‹Ð¼ Ð² Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ [Ð¸Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ð¸ Ð¿Ð¾ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸ÑŽ Abilities](../abilities.md), Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð°Ð´Ð°Ð¿Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð¿Ð¾Ð´ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ðµ Ð½ÑƒÐ¶Ð´Ñ‹.